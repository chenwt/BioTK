#!/usr/bin/env bash

usage() {
    cat <<EOF
Like GNU cut, but with a few extra options to deal with data containing a
header (column names).

USAGE: $0 <options>
options:
    -d : the field delimiter (default tab)
    -F <comma-separated list of column names> :
        cut the columns with these column names
    -p : preserve the column headers
    -h : show this help

Limitations:
- bona fide commas in field names cannot be escaped
- as with GNU cut, the fields will be returned in their sequential order
  within each row, not necessarily in the order they were requested
EOF
    exit 1
}

delimiter=$'\t'
field_names=
preserve_header=

while getopts d:F:p opt; do
    case $opt in 
        d) delimiter="$OPTARG" ;;
        F) field_names="$OPTARG" ;;
        p) preserve_header="y" ;;
        h) usage ;;
    esac
done

read header

fields=()
IFS=',' 
for name in $field_names; do
    j=$(echo "$header" | indexof -l"$name" -d"$delimiter")
    if [ $j -ne 0 ]; then
        fields+=($j)
    fi
done
unset IFS

{
    if [[ $preserve_header == "y" ]]; then
        echo "$header"
    fi
    cat
} | cut -d"$delimiter" -f"$(echo ${fields[@]} | tr ' ' ',')"
