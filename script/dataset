#!/usr/bin/env python3

import inspect

import networkx as nx

# Types of target:
# - downloads
# - compute and save
# - side effect (like make help)

"""
class PipelineTarget(object):
    def __init__(self, name, path=None, requires=None, cache=True):
        self.name = name
        self.requires = requires or []
        if path is None:
            path = self.name

    def __call__(self, fn):
        self.run = fn

    def run(self):
        raise NotImplementedError

class Pipeline(nx.DiGraph):
    def __init__(self, name=None):
        self.name = name
        super(nx.DiGraph, self).__init__()

    def target(self, name):
        def register(fn):
            pass

# Pipeline

dataset = Pipeline("dataset")

@dataset.target("ncbi/geo/miniml/${accession}.ptxz")
def fn(accession):
    pass

@dataset.target("ncbi/gene/info")
def fn():
    pass
"""

import itertools as it
from collections import OrderedDict
import csv
import sys

import dataset

class DataStore(object):
    """
    Store multiple tabular datasets in a SQL database without
    explicitly specifying schemata.
    """
    def __init__(self, *args, **kwargs):
        self.funcs = {}
        self.db = dataset.connect(*args, **kwargs)

    def __getitem__(self, key):
        if not key in self.funcs:
            raise KeyError(key)
        create = key not in self.db.tables
        if create:
            fn = self.funcs[key]
            table = self.db.create_table(key, primary_id="_id")
            rows = fn()
            # TEST MODE
            #rows = it.islice(rows, 10)
            ###########
            table.insert_many(rows)
        else:
            table = self.db[key]
        return table

    def _delimited(self, key, **kwargs):
        """
        Wrap a function returning a file handle to a text-delimited file.
        """
        def register(fn):
            def wrap():
                with fn() as handle:
                    rdr = csv.reader(handle, **kwargs)
                    header = next(rdr)
                    for fields in rdr:
                        yield OrderedDict(zip(header, fields))
            self.funcs[key] = wrap
            return wrap
        return register

    def tsv(self, key):
        return self._delimited(key, delimiter="\t")

    def records(self, key):
        """
        Wrap a function returning a sequence of dict or OrderedDict objects.
        """
        def register(fn):
            self.funcs[key] = fn
            return fn
        return register

    #def to_tsv(self, key, file=sys.stdout):

#store = DataStore("sqlite://")
store = DataStore("sqlite:////home/gilesc/data/BioTK.db")

import BioTK.cache
@store.records("ncbi/gene/info")
def fn():
    import gzip
    columns = ["Taxon ID", "Gene ID", "Symbol", "Name"]
    url = "http://ftp.ncbi.nih.gov/gene/DATA/gene_info.gz"
    path = BioTK.cache.download(url)
    with gzip.open(path, "rt") as h:
        next(h)
        for line in h:
            fields = line.strip("\n").split("\t")
            row = [fields[ix] for ix in [0,1,10,11]]
            row[0] = int(row[0])
            row[1] = int(row[1])
            yield OrderedDict(zip(columns, row))

if __name__ == "__main__":

    key = sys.argv[1]
    table = store[key]
    rows = table.all()
    #dataset.freeze(rows, format="tsv", fileobj=sys.stdout)

    print(*table.columns[1:], sep="\t")
    for row in rows:
        print(*list(row.values())[1:], sep="\t")

#db = dataset.connect("sqlite:////home/gilesc/test.db")
#db = dataset.connect("sqlite://")
#table = db["ncbi/gene/info"]
