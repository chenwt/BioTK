#!/usr/bin/env python3

import time
import os
import tempfile
import pickle
import sys
import subprocess as sp
import shutil
import inspect

import functools
import click
import sklearn.linear_model
import sklearn.ensemble
import sklearn.svm
from sklearn.cross_validation import cross_val_score
import sklearn.metrics
import numpy as np

import BioTK
import BioTK.learn.cv

@click.group()
def cli():
    pass

def _get_model_class(ctx, _, model_str):
    model_module, model_class = model_str.rsplit(".",1)
    model_class = getattr(sys.modules[model_module],model_class)
    kwargs = {}
    try:
        if "probability" in inspect.getargspec(model_class.__init__)[0]:
            kwargs["probability"] = True
    except:
        pass
    return model_class(**kwargs)

def _read_predictors(ctx, _, handle):
    with handle:
        return BioTK.io.read_matrix(handle).to_frame()

def _read_labels(cx, _, handle):
    with handle:
        return BioTK.io.read_vector(handle)

def error(*msgs, return_code=1):
    print(*msgs, file=sys.stderr)
    sys.exit(return_code)

def ml_command(fn):
    @functools.wraps(fn)
    def wrapper(model, X, y, *args, **kwargs):
        X = X.dropna(axis=1, how="any").dropna(axis=0, how="any")
        y = y.dropna()
        X,y = X.align(y, axis=0, join="inner")
        if len(set(y)) <= 1:
            error("ERROR: Less than two label values align with data.")
        if X.shape[0] < 5:
            error("ERROR: Not enough labeled data.")
        return fn(model, X, y, *args, **kwargs)

    return cli.command()(
           click.option("X", "--predictors", "-p", 
                callback=_read_predictors,
                type=click.File("r"), default=sys.stdin)(
           click.option("model", "--model-class", "-m", 
                callback=_get_model_class,
                default="sklearn.linear_model.LogisticRegression")(
           click.argument("y",
               callback=_read_labels,
               type=click.File("r"))(wrapper))))

@ml_command
def train(model, X, y):
    model.fit(X,y)
    pickle.dump(model, sys.stdout.buffer)

@ml_command
@click.option("--metric", default="roc_auc")
@click.option("--folds", "-k", type=int, default=10)
@click.option("--output-predictions", "-P", is_flag=True)
@click.option("--round-digits", "-r", type=int, default=3)
def cv(model, X, y, folds, metric, output_predictions, round_digits):
    if output_predictions:
        y_hat = BioTK.learn.cv.predictions(model, X, y, k=folds, n_jobs=0)
        for id, y, yh in zip(y.index, y, y_hat):
            if not np.isnan(yh):
                if round_digits:
                    yh = round(yh, round_digits)
                print(id, y, yh, sep="\t")
    else:
        scores = cross_val_score(model, X, y, cv=folds, scoring=metric)
        print(round(y.mean(), 3), 
                len(y), 
                round(scores.mean(), 3), 
                sep="\t")

###############
# Vowpal Wabbit
###############

@cli.group("vw")
def vw():
    pass

def _format_vw_key(k):
    if isinstance(k,int) or k.isdigit():
        return "X"+str(k)
    return k.replace("-","_")

@vw.command("convert")
@click.argument("labels", type=click.File("r"))
def vw_convert(labels):
    labels = BioTK.io.read_vector(labels)
    if len(set(labels)) == 2:
        hi = labels==labels.max()
        lo = labels==labels.min()
        labels[hi] = 1
        labels[lo] = -1
        labels = labels.astype(int)
    rows = BioTK.io.read_matrix(sys.stdin)
    for row in rows:
        if row.name in labels:
            y = labels[row.name]
            row = row.dropna()
            rhs = " ".join(("%s:%s" % (_format_vw_key(k),v) 
                for k,v in zip(row.index, row)))
            print(y, "|d", rhs)

def _vw_cross_validate(tmpdir, k):
    with tmpdir:
        assert k > 1
        y = []

        splits = {} 
        paths = {}
        for i in range(k):
            paths[i] = "%s/%s.vw" % (tmpdir.name, i)
            splits[i] = open(paths[i], "w")
        for i,line in enumerate(sys.stdin):
            h = splits[i % k]
            y.append(float(line.split(" ", 1)[0]))
            h.write(line)
        for h in splits.values():
            h.close()

        y_hat = np.zeros(len(y))

        processes = []
        for i in range(k):
            data_path = "%s/%s.data" % (tmpdir.name, i)
            with open(data_path, "w") as train:
                for fold,path in paths.items():
                    if not fold == i:
                        with open(path) as input:
                            for line in input:
                                train.write(line)

            model_path = "%s/%s.model" % (tmpdir.name, i)
            p = sp.Popen(["vw", 
                "-c", "--passes=10",
                "-d", data_path,
                "-b", "29",
                #"--nn", "12",
                #"--l1=0.001", 
                #"--invariant",
                #"--normalized",
                #"--bfgs",
                #"--l2=0.001",
                "--loss_function=logistic",
                "-f", model_path])
            processes.append(p)

        while True:
            if not all([p.poll() is not None for p in processes]):
                time.sleep(1)
            else:
                break

        for i in range(k):
            yhat_path = "%s/%s.yhat" % (tmpdir.name, i)
            p = sp.call(["vw", "-t", "-i", model_path, 
                "-r", yhat_path],
                stdin=open(paths[i], "r"))
            with open(yhat_path) as h:
                for j,line in enumerate(h):
                    # if using --nn option, prediction is last element
                    # otherwise, output *should* just be a plain float per line
                    y_hat[j*(i+1)] = float(line.split()[-1])

        # FIXME: this will only work for binary
        y_hat = 1 / (1 + np.exp(-y_hat))

        for i in range(len(y_hat)):
            print(y[i], y_hat[i], sep="\t")

@vw.command("cv")
@click.option("--folds", "-k", type=int, default=10)
def vw_cross_validate(folds):
    tmpdir = tempfile.TemporaryDirectory()
    _vw_cross_validate(tmpdir, folds)

if __name__ == "__main__":
    cli()
