#!/usr/bin/env python
"""
Pipe data while a condition holds; if it fails to hold, block until it holds again.

USAGE: catwhile [options] < data

options:
    -f <path> : file/folder to watch 
    -s <size> : max size of watched file/folder (in MB)

NOTES
-----

Currently, the only implemented condition is to check the disk usage of a file/folder.
"""

import argparse
import os
import sys
import time

MB = 2 ** 20
BUFFER_SIZE = 10 * MB

def path_size(path):
    size = 0
    for base, dirs, files in os.walk(path):
        for f in files:
            try:
                size += os.path.getsize(os.path.join(base, f))
            except FileNotFoundError:
                continue
    return size

if __name__ == "__main__":
    p = argparse.ArgumentParser()
    p.add_argument("--watch-path", "-p")
    p.add_argument("--max-size", "-s", type=float)
    p.add_argument("--verbose", "-v", 
            action="store_true")
    args = p.parse_args()

    stdin, stdout = sys.stdin.detach(), sys.stdout.detach()
    # This prevents the wrappers from failing to be GCed on program close,
    # causing a message on stderr
    sys.stdout = sys.stdin = None

    while True:
        data = stdin.read(BUFFER_SIZE)
        if len(data) == 0:
            break
        while True:
            size = path_size(args.watch_path)
            if size <= args.max_size * MB:
                break
            if args.verbose:
                print("catwhile: size limit exceeded: (%d / %d MB)" % (size / MB, args.max_size), 
                        file=sys.stderr)
            time.sleep(5)
        stdout.write(data)
