#!/usr/bin/env bash

tc=tcbmgr
ext=.xmat

_fix_input() {
    awk '
        BEGIN {
            FS=OFS="\t"
        }
        {
            for (i=2; i<=NF; i++) {
                if ($i == "") {
                    $i="nan"
                }
            }
            print
        }'
}
export -f _fix_input

load() {
    export path="$1"

    $tc create -tl -td "${path}"
    read -r header
    {
        echo "$header" \
            | awk 'BEGIN { FS=OFS="\t" } { $1="_index"; print }'
        parallel --pipe _fix_input 
    } | $tc importtsv -nb "${path}"
}

_print_header() {
    path="$1"
    echo -ne "\t"
    $tc get -nl "${path}" _index
}

_parse_file() {
    if [[ $1 == "-" ]]; then
        echo "/dev/stdin"
    else
        echo "$1"
    fi
}
export -f _parse_file

query() {
    query_usage() {
        echo "USAGE: xmat query [ -r <path> -c <path> ]"
        echo
        echo "  where <path> is a path to a file containing IDs, one per line,"
        echo "  or '-' for stdin"
    }

    local OPTIND
    while getopts r:c:h opt; do
        case $opt in
            r) r=$(_parse_file $OPTARG) ;;
            c) c=$(_parse_file $OPTARG) ;;
            h) query_usage && exit 0 ;;
            ?) query_usage && exit 1 ;;
        esac
    done
    shift $((OPTIND - 1))
    path="$1"
    [[ -z "$path" ]] && query_usage && exit 1

    {
        _print_header $path

        {
            if [[ -z "$r" ]]; then
                $tc list -nl "${path}" | grep -v _index
            else
                cat "$r"
            fi | while read pkey; do
                $tc get -nl "$path" "$pkey" 2> /dev/null | IFS='' read -r value
                if [ ! -z "$value" ]; then
                    echo -e "$pkey\t$value"
                fi
            done 
        }
    } | if [[ ! -z "$c" ]]; then
        select-columns "$c"
    else
        cat
    fi
}

dump() {
    path="$1"
    query -r <($tc list -nl "${path}" | grep -v _index) $path
}

cmd="$1"
shift
$cmd "$@"
