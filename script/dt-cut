#!/usr/bin/env python3

# Like the "cut" utility, but can cut by field names or positions.
# For compatibility with "cut", fields are one-indexed
# when specified by position.

import argparse
import itertools
import sys

p = argparse.ArgumentParser()
p.add_argument("--fields", "-f")
p.add_argument("--names", "-n")
p.add_argument("--delimiter", "-d", default="\t")
p.add_argument("--omit-header", "-H", action="store_true")
p.add_argument("file", type=argparse.FileType("r"),
        default=sys.stdin, nargs="?")
args = p.parse_args()

if args.fields and args.names:
    print("conflicting options: -f and -n", file=sys.stderr)
    sys.exit(1)
if not args.fields and not args.names:
    print("one of -f and -n is required", file=sys.stderr)
    sys.exit(1)

header = next(args.file)
if args.names:
    fields = []
    names = args.names.split(",")

    counts = {}
    for n in names:
        counts[n] += 1
    non_unique = set(k for k,v in counts.items() if v > 1)

    name_position = dict(map(reversed,enumerate(header.split(args.delimiter))))
    for n in args.names.split(","):
        n = n.strip('"').strip("'")
        if n in non_unique:
            print("specified column is not unique:", 
                    n, file=sys.stderr)
        try:
            fields.append(name_position[n])
        except KeyError:
            print("no such column:", n, file=sys.stderr)
else:
    fields = []
    for x in args.fields.split(","):
        if "-" in x:
            start, end = map(int, x.split("-"))
            fields.extend(range(start-1,end))
        else:
            fields.append(int(x)-1)


if not args.omit_header:
    lines = itertools.chain([header], args.file)
else:
    lines = args.file

for line in lines:
    xs = line.rstrip("\n").split(args.delimiter)
    print(*[xs[i] for i in fields], sep=args.delimiter)
